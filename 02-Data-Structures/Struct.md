# Rust 结构体： 数据是怎么躺在内存里的？

在系统级编程中，如何组织数据直接决定了程序的运行效率。很多高级语言在创建一个“对象”时，会自动附带对象头（Object Header）、虚表指针（vtable pointer）等额外开销。但在 Rust 中，结构体（Struct）的设计目标非常明确：**你没写下的字段，内存里绝对不会出现。**

这种对内存的精确掌控，让结构体成为了 Rust 实现零成本抽象的基石。

---

## 1. 零成本抽象：物理上消失，逻辑上存在

Rust 的结构体不仅能承载数据，还能在不增加运行负担的前提下，为程序提供强大的逻辑约束。这主要体现在两个方面：

### A. 空结构体与 ZST (Zero Sized Type)
如果你定义一个没有任何字段的结构体，它的大小是 **0 字节**。

```rust
struct Empty; // 单元结构体（Unit-like Struct）
```

你可以把它想象成内存里的“幽灵字段”：它在代码逻辑中真实存在，但在物理内存中不占任何字节。这在 **状态模式（State Pattern）** 中非常有用：

```rust
struct Initialized;
struct Running;

struct Worker<S> {
    state: S, // S 是 ZST，不占空间
    id: u32,
}
```

`Worker<Initialized>` 和 `Worker<Running>` 的内存大小完全相同（仅占 `id` 的 4 字节），让我们能安全地在类型系统中切换状态，而付出的代价是零。

### B. 类型包装与 Newtype
有时候我们想给 `u32` 起个名字叫 `Meters`，用来防止不小心把“长度”和“重量”相加。

```rust
struct Meters(u32); // 元组结构体（Tuple Struct）
```

这种模式被称为 **Newtype**。在 Rust 中，这种包装层仅存在于编译阶段的类型检查中。一旦程序运行起来，这些包装层就会彻底消失，`Meters` 会直接映射为底层的 `u32`。

它就像是给数据戴上了一个“语义面具”：在编译器眼里它是长度，在 CPU 眼里它依然是那个熟悉的 4 字节整数。所有的类型检查都发生在编译阶段，而运行期的代价是零。

### 内存透视
下面的图示直观展示了 ZST 和 Newtype 是如何在内存中“隐形”的：

![ZST 与 Newtype 布局](./imgs/struct_zst_newtype.svg)

- **PART 1**: 即使插入 ZST 字段，内存依然紧凑排列。
- **PART 2**: Newtype 包装层在运行期彻底消失，直接映射到原始数据。

---

## 2. 如果字段变多了，编译器会怎么排布它们？

当我们往结构体里塞入不同大小的数据（比如一个 `u8` 和一个 `u32`）时，事情变得复杂了。

### 对齐带来的空隙
现代 CPU 访问内存是有“偏好”的。读取一个 4 字节的整数时，如果它的地址能被 4 整除，效率最高。为了迎合 CPU，编译器会在字段之间插入一些看不见的字节，这叫 **填充（Padding）**。

### 自动重排优化
在 C 语言中，字段必须按你写的顺序排列。但在 Rust 中，编译器会自动重新排列字段顺序，把小的字段塞进大的填充缝隙里，从而减小整个结构体的大小。

```rust
struct MyData {
    a: u8,
    b: u32,
    c: u8,
}
```

在 C 语言中这可能占 12 字节，但在 Rust 中，编译器会把 `a` 和 `c` 凑在一起，最终只占 8 字节。

![结构体内存对齐与填充](./imgs/struct_alignment.svg)

---

## 3. 数据排布好了，那它怎么管理生命周期？

结构体不仅决定了数据怎么躺在内存里，还决定了这些数据什么时候被销毁。

### 所有权与递归
Rust 要求结构体的大小在编译期必须是固定的。为了实现递归结构（如链表），我们需要引入 **Box** 将递归部分移到堆内存中，从而使栈上的指针大小固定。

![递归结构体与堆内存分配](./imgs/struct_recursive.svg)

### 借用的约束
如果结构体包含引用，必须使用生命周期标注（如 `<'a>`）。这并不是存储额外数据，而是给编译器画红线：**结构体的寿命绝对不能超过它内部引用的数据。**本文就不再过多赘述了，后续会专门会写一篇图解生命周期的文章介绍。

---

## 4. 行为与数据：各司其职

在 Rust 中，数据放在 `struct` 里，逻辑放在 `impl` 块里。这种“数据归数据，逻辑归逻辑”的做法，本质上是为了在保持高性能的同时，让代码更好读、好管。

### 内存里只有数据
一个很重要的点是：**`struct` 实例本身是不占任何额外内存来存储方法的。** 
如果你定义了一个包含两个 `i32` 的结构体，它在内存里就是那 8 个字节。不管你给它写了 10 个方法还是 100 个方法，它的内存大小都不会变。

![行为与数据分离的内存图景](./imgs/struct_behavior_data.svg)

当你调用 `p.distance()` 时，并没有什么“运行时查找方法”的过程。编译器在编译时就已经知道该去哪运行这段代码了。

### 静态分发：编译器的“搜索替换”
很多面向对象语言的对象可能会带有一个“虚表指针”，用来实现多态。但在 Rust 的结构体里，默认是 **静态分发**。

简单来说，编译器帮你做了一次简单的替换：`p.distance()` 在底层其实就是 `Point::distance(&p)`。因为调用哪个函数在编译时就完全确定了，编译器甚至可以直接把函数代码“复制”到调用的地方（也就是内联优化），连函数调用的开销都省了。

### 相比 C 语言，它好在哪？
如果你写过 C，你会发现这其实就是 C 语言“结构体 + 全局函数”的升级版。

![Rust impl 与 C 函数对比](./imgs/rust_vs_c_impl.svg)

虽然底层跑起来逻辑差不多，但 Rust 的写法省了不少心：
- **不用担心重名**：在 C 里你可能得起名 `my_project_point_distance` 这种长名字来防重名，Rust 里方法直接跟类型绑定，名字短小且清晰。
- **写起来更顺手**：你可以用 `p.do_a().do_b()` 这样连着写（链式调用），而不用像 C 那样写成套娃：`do_b(do_a(p))`。
- **编译器帮你干杂活**：如果方法定义需要引用 `&self`，你直接调 `p.distance()` 就行，Rust 会自动帮你取地址。而在 C 里，你必须时刻记得写 `&p`。

总的来说，Rust 的 `impl` 就是把 C 语言那种散乱的写法给“规整”了。它穿上了现代语言的漂亮外衣，但骨子里依然保留了 C 语言那种直接、高效的内存逻辑。

---

## 5. 当你需要手动接管布局时

有时我们需要和外部环境（如 C 语言库）打交道，或者有极端的空间需求。这时可以使用 `#[repr]` 属性来显式控制结构体的内存排布：

```rust
// 1. 默认布局：编译器会为了性能和空间进行自动重排
struct RustData { a: u8, b: u32, c: u8 } // Size: 8

// 2. C 兼容布局：强制按书写顺序排列，禁用重排（常用于 FFI）
#[repr(C)]
struct CData { a: u8, b: u32, c: u8 } // Size: 12 (含填充)

// 3. 紧凑压缩：取消所有填充，牺牲访问性能换取空间（慎用！）
#[repr(packed)]
struct PackedData { a: u8, b: u32, c: u8 } // Size: 6

// 4. 零开销包装：保证包装类与内部字段在内存中完全一致
#[repr(transparent)]
struct Wrapper(u32); // Size: 4 (与 u32 相同)
```

![结构体内存布局控制](./imgs/struct_repr.svg)

- **`repr(Rust)`**：默认行为，允许编译器重排字段以消除对齐产生的空隙。
- **`repr(C)`**：严格遵循书写顺序，适合与 C 语言进行跨语言调用。
- **`repr(packed)`**：移除所有填充字节，适用于某些对内存占用极其敏感的底层协议。
- **`repr(transparent)`**：用于只有一个非零大小字段的结构体，确保其内存布局与该字段一致。

---

## 6. 总结

总的来说，Rust 的结构体其实就是为了兼顾两件事：

- **逻辑上的安全感**：利用类型系统，在编译阶段就把数据使用的错误挡在门外。
- **底层上的透明度**：在内存里，它尽可能做到“所见即所得”，没有任何多余的隐藏开销。

你可以把它看作是一个“不搞黑盒操作”的容器：你定义了什么，它在内存里就怎么躺着。这种确定性，正是 Rust 能够兼顾开发效率和运行性能的关键。

> **声明**：本文核心观点及每张视觉图表的设计均由作者原创构思，文章内容经由 AI 辅助润色与纠错。既然工具能帮我们将思考表达得更精准，那便没必要在文字修辞上自欺欺人，让创作回归本质才是最重要的。
