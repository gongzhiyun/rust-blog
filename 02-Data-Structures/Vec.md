# 深度解构 Rust Vec<T>：从 24 字节到物理重排

> 为什么一个能存储数百万个元素的 `Vec<T>`，在栈上永远只占用固定的 24 个字节？当数据量突破容量限制时，内存中究竟发生了怎样的“物理位移”？

在 Rust 的世界里，`Vec<T>` 是最常用的动态集合，但它的“动态性”背后隐藏着极其严苛的内存布局和物理逻辑。

```rust
// 原型：在 64 位系统下，Vec<T> 的物理结构由三个 usize 字段组成
let mut v: Vec<u8> = Vec::with_capacity(4);
v.push(10);
v.push(20);
```

## 1. 物理结构：三元组的职能

在 64 位系统下，`Vec<T>` 在**栈（Stack）**上占据连续的 **24 字节**（3 * 8 bytes），这 24 字节是管理海量数据的“司令部”：

![Vec 内存布局](./imgs/vec_layout_v2.svg)

-   **ptr (Pointer)**: 
    -   **物理本质**: 保存了堆内存分配器返回的原始起始地址。
    -   **寻址逻辑**: 所有的元素访问本质上都是基址偏移计算：`addr = ptr + index * size_of::<T>()`。
    -   **所有权**: 内部使用 `Unique<T>` 封装，向编译器声明它拥有这块内存的所有权。
-   **cap (Capacity)**: 
    -   **职能**: 标识了当前已申请堆空间的**物理上限**。
    -   **性能边界**: 只要 `len < cap`，`push` 操作仅涉及一次内存写入（memcpy）和 `len` 的自增，时间复杂度为 $O(1)$。
-   **len (Length)**: 
    -   **职能**: 划定了“已初始化”的安全区。
    -   **物理检查**: Rust 所有的索引访问都会进行边界检查（Bounds Check），即 `index < len`。越过此边界将触发 `panic`，这是防止越界访问（Buffer Overflow）的最后防线。

---

## 2. 扩容：昂贵的堆数据搬迁

当 `len` 试图超越 `cap` 时，`Vec` 无法在原地“膨胀”，必须触发一次**物理级的重排**：

```rust
let mut v = Vec::with_capacity(4);
v.extend([1, 2, 3, 4]); // 此时 len=4, cap=4

// 触发扩容：申请新空间(8) -> 拷贝数据 -> 更新指针 -> 释放旧空间
v.push(5); 
```

![Vec 扩容示意图](./imgs/vec_expansion.svg)

1.  **申请新空间**: 调用分配器（Allocator）申请通常为原容量 2 倍的新内存块。
2.  **物理拷贝 (memcpy)**: 将旧地址的数据逐字节搬运至新地址。注意，这里是浅拷贝（Bitwise Copy），因为 Rust 的所有权模型保证了旧数据不会再被使用。
3.  **指针重定向**: 更新栈上的 `ptr` 为新地址，并同步更新 `cap`。
4.  **释放旧内存**: 将旧的堆空间归还给操作系统。

> 频繁扩容会导致内存抖动和 CPU 周期浪费。如果你预先知道数据量，务必使用 `Vec::with_capacity(n)`。这不仅是性能优化，更是对内存分配器的尊重。

---

## 3. 幽灵模式：ZST (零大小类型)

如果 `T` 是一个 ZST（如 `()` 或 `struct Empty;`），`Vec` 会进入一种奇妙的“幽灵模式”：

```rust
struct Empty; // 零大小类型 (ZST)

let mut v = Vec::new();
for _ in 0..1_000_000 {
    v.push(Empty); // 即使 push 一百万次，也不会触发堆分配
}
```

![ZST 内存布局](./imgs/vec_zst_layout.svg)

-   **无堆分配**: 因为 `size_of::<T>()` 为 0，申请堆空间纯属浪费。
-   **ptr 的伪装**: `ptr` 会被设置为一个悬空指针 `NonNull::dangling()`（通常是 0x01）。它不指向任何实际内存，但满足“非 null”的契约。
-   **cap 的无穷大**: 对于 ZST，`cap` 实际上被视为 `usize::MAX`。你可以向里面 `push` 十亿个元素，它永远不会扩容，因为物理占用始终为 0。

> 这种特性最典型的应用是 `HashSet<T>`。在 Rust 标准库中，`HashSet<T>` 实际上是 `HashMap<T, ()>` 的封装。由于 `()` 是 ZST，这使得 `HashSet` 在存储键时，其值（Value）部分完全不占用物理空间。此外，这种“零成本计数”也常用于类型状态（Type-state）编程，利用类型系统在编译期进行逻辑约束而无需运行期开销。后续计划专门写一篇分析`HashSet<T>`的文章。

---

## 4. 零成本转换：Vec vs Slice

`Vec<T>` 与切片 `&[T]` 的转换是 Rust 零成本抽象的典范：

```rust
let mut v: Vec<u8> = Vec::with_capacity(4);
v.extend([1, 2, 3]); // len=3, cap=4

let s: &[u8] = &v;    // 隐式转换或 v.as_slice()
```

![从 Vec 到 Slice 的物理转换](./imgs/vec_to_slice.svg)

-   **解构**: 当你调用 `v.as_slice()` 时，内核仅需从栈上拷贝 `ptr` 和 `len`。
-   **胖指针 (Fat Pointer)**: 生成一个 16 字节的结构（Pointer + Length），直接指向 `Vec` 的堆空间。
-   **物理消耗**: 整个过程仅涉及寄存器级别的数值搬运，没有任何堆分配，也没有任何内存拷贝。

> 这种转换本质上是内存所有权与访问权限的重新切分。通过在栈上重新组合 `ptr` 和 `len`，Rust 实现了从“拥有数据的集合”到“观察数据的窗口”的无缝切换，而底层的堆内存保持完全不动。

## 5. 总结

理解 `Vec` 的物理本质后，你会发现其设计的精髓在于极致的**栈堆分离**：

在 Rust 中，`Vec` 的 24 字节“栈司令部”与海量的“堆数据”之间存在一种微妙的代理关系。这种设计不仅是为了动态扩容，更是为了实现**确定性的性能预期**。

当你把一个拥有百万元素的 `Vec` 从一个函数传给另一个函数时，发生物理位移的仅仅是栈上的那三个字长（ptr, cap, len）。这种“所有权转移”在汇编层面仅仅是几条寄存器指令的拷贝，其代价与传递一个整数几乎无异。

这种分离让 Rust 能够以极低的代价实现复杂的语义：你可以拥有动态伸缩的灵活性（堆），同时保持对内存元数据操作的恒定开销（栈）。这就是为什么 `Vec` 乃至 Rust 的许多集合类型，都能在保持高级抽象的同时，依然拥有不输于 C 语言的运行效率。

> **声明**：本文核心观点及每张视觉图表的设计均由作者原创构思，文章内容经由 AI 辅助润色与纠错。既然工具能帮我们将思考表达得更精准，那便没必要在文字修辞上自欺欺人，让创作回归本质才是最重要的。
