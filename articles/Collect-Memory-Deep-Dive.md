# 从内存视角理解 collect

在 Rust 的开发实践中，`collect` 是将抽象的迭代器逻辑转化为具体物理存储的核心枢纽。它不仅能将延迟计算的序列泵入 `Vec`、`HashMap` 等容器，更在底层封装了一系列复杂的内存优化策略。

当我们调用 `.collect()` 时，程序并非只是机械地循环插入数据。为了实现真正的“零成本抽象”，标准库在底层利用迭代器的自省能力，通过精准的预分配、边界检查消除以及缓冲区重用等手段，极大地减少了运行时的内存开销。本文将带你透视 `collect` 的底层逻辑，揭示 Rust 是如何在保持高层抽象的同时，实现极致的物理内存性能。

## 从非堆数据源 (Range) 开始

```rust
let v: Vec<_> = (0..10).map(|x| x + 1).collect();
```

当执行到 `collect()` 时，底层面临的首要挑战是确定堆内存的申请规模。由于 `Range` 结构体只在**栈**上存储 `start` 和 `end`，堆上最初完全没有这组数据。

为了规避频繁扩容带来的拷贝损耗，Rust 采用“先自省、再分配”的策略：
- **逻辑自省**：触发迭代器链的 `size_hint()`，在本例中返回精确值 10。
- **物理落地**：根据预估值一次性申请堆空间，并将数据直接写入。

![从非堆数据源开始](./imgs/collect_from_range.svg)

## 就地重用 (In-place Reuse)

当你将一个 `Vec` 消耗掉（通过 `into_iter`）并转换成另一个 `Vec` 时，如果转换前后的类型（源类型 `T` 和目标类型 `U`）具有**相同的尺寸 (Size) 和对齐量 (Alignment)**，Rust 会开启极致优化。

```rust
let v1: Vec<i32> = (0..10).collect();
let v2: Vec<i32> = v1.into_iter().map(|x| x + 1).collect();
```

在这段代码中，`v2` 会**直接重用** `v1` 曾经占用的堆缓冲区：
1. **所有权接管**：`into_iter()` 将堆指针的所有权转移给迭代器。
2. **零分配覆盖**：`collect` 直接在原地址 (如 `0x500`) 覆盖写入新数据。
3. **特快路径**：利用 `TrustedLen` 标记消除边界检查，实现指令级的直写。

![就地重用](./imgs/collect_inplace_vec.svg)

## 借用与新分配 (Borrow & Allocation)

如果数据源是借用的（通过 `iter`），情况则完全不同。

```rust
let v1: Vec<i32> = (0..10).collect();
let v2: Vec<i32> = v1.iter().map(|x| x + 1).collect();
```

在这种情况下：
1. **物理隔离**：由于 `v1` 仍然持有其堆内存的所有权且可能在后续继续使用，`collect` **必须**开辟一块全新的内存区域。
2. **独立布局**：此时堆上会同时存在两块独立的内存区域：一块是只读的源数据，另一块是新生成的计算结果。

![借用与新分配](./imgs/collect_borrow_vec.svg)

## 总结

`collect` 的高性能源于它对内存物理特性的极致榨取：
- 通过 **`size_hint`** 规避昂贵的重分配。
- 通过 **`TrustedLen`** 赋予编译器更强的优化信息。
- 通过 **`In-place`** 机制实现了内存空间的物理级复用。

这种从高层语法到底层内存布局的完美映射，正是 Rust 性能哲学的核心体现。
